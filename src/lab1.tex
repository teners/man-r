\psection{Лабораторная работа №1}
\textbf{Основы обработки статистических данных в R. \\ \indent Выборочные характеристики.}
\begin{enumerate}
	\item Получите две выборки объемом 50 и 30 значений из нормально распределенных генеральных совокупностей с разными значениями параметров.\\
		Для этого стоит воспользоваться функцией \texttt{rnorm}.

		\begin{mdframed}[style=BadassFrame]

              \texttt{rnorm(n, mean = 0, sd = 1)} \\
              	-- генерирует \texttt{n} нормально распределенных чисел (\texttt{n} наблюдений)

              \begin{description}

                \item[n] -- число наблюдений
                \item[mean] -- (необязательный) матожидание случайной величины
                \item[sd] -- (необязательный) среднее квадратическое отклонение
              \end{description}
        \end{mdframed}

		Пример использования:\\
		\texttt{>rnorm(4, mean=10, sd=3)}\\
		\texttt{[1] 12.603994 10.818511  9.115428  6.367522}

	\item По объединенной выборке, моделирующей выборку из конечной смеси двух распределений, 
		составьте вариационный ряд (выборку, упорядоченную по возрастанию значений).
		Конкатенацию элементов можно осуществить при помощи функции \texttt{c()}. \\
		Затем объединенную выборку можно отсортировать используя функцию \texttt{sort()}. 
		Для этого достаточно передать ей как аргумент ваш вектор. 

		\begin{mdframed}[style=BadassFrame]

              \texttt{sort(x, decreasing = FALSE)} \\
              	-- осуществляет сортировку элементов вектора
              \begin{description}

                \item[x] -- сортируемый вектор
                \item[decreasing] -- (необязательный) порядок сортировки. По умолчанию сортирует в 
                	порядке возрастания (FALSE)
              \end{description}
        \end{mdframed}

		Пример использования:\\
		\texttt{> y} \\
 		\texttt{[1]  3.064658  0.952703  2.458550  7.531425  4.424056 -1.004320  9.993588} \\
 		\texttt{[8]  6.985664  4.892350  1.910246} \\
        \texttt{> y <- sort(y)} \\
		\texttt{> y} \\
		\texttt{ [1] -1.004320  0.952703  1.910246  2.458550  3.064658  4.424056  4.892350} \\
		\texttt{ [8]  6.985664  7.531425  9.993588}

	\item Найдите выборочные характеристики, в скобках указаны функции, которые следует использовать для получения значения:
		\begin{itemize}
			\item[--] Наибольшее значение, \texttt{(min)};
			\item[--] Наименьшее значение, \texttt{(max)};
			\item[--] Объем выборки, \texttt{(length)};
			\item[--] Выборочное среднее, \texttt{(mean)};
			\item[--] Медиану: значение, которое делит вариационный ряд на две равные (по числу значений) части, \texttt{(median)};
			\item[--] Вариационный размах (размах выборки): разница между наибольшим и наименьшим значениями выборки, \texttt{(max - min)}; 
			\item[--] Исправленную (несмещенную) выборочную дисперсию, \texttt{(var)};
			\item[--] Выборочное среднее квадратическое отклонение, вычисленное по исправленной (несмещенной) выборочной дисперсии, \texttt{(sd)};
		\end{itemize}
		Все перечисленные выше функции достаточно вызвать с одним аргментом - вашим вектором значений.

        \begin{mdframed}[style=BadassFrame]

              \texttt{var(x, y = NULL, na.rm = FALSE, use)} \\ -- вычисляет дисперсию набора величин
              \begin{description}

                \item[x] -- первый набор
                \item[y] -- (необязательный) второй набор (аргумент по умолчанию эквивалентен y=x, но более эффективен )
                \item[na.rm] -- (необязательный) должны ли отбрасываться отсутствующие значения (NA)? (нет по умолчанию)
                \item[use] -- (необязательный) метод вычисления дисперсии в случае отсутствия некоторых значений
                     \texttt{``everything''} (по умолчанию),  \texttt{``all.obs'', ``complete.obs'', ``na.or.complete'', ``pairwise.complete.obs''}
              \end{description}
        \end{mdframed}

		\begin{mdframed}[style=BadassFrame]

              \texttt{mean(x)} \\ 
              	-- находит арифметическое среднее набора значений \texttt{x}
              \begin{description}

                \item[x] -- набор значений
              \end{description}
        \end{mdframed}

        \begin{mdframed}[style=BadassFrame]

              \texttt{median(x, na.rm = FALSE)} \\
              	-- вычисляет медиану набора значений \texttt{x}
              \begin{description}

                \item[x] -- набор значений
                \item[na.rm] -- (необязательный) должны ли отбрасываться отсутствующие значения (NA)? (нет по умолчанию)
              \end{description}
        \end{mdframed}

        \begin{mdframed}[style=BadassFrame]

              \texttt{sd(x, na.rm = FALSE)} \\
              	-- вычисляет среднее квадратическое отклонение набора значений \texttt{x}
              \begin{description}

                \item[x] -- набор значений
                \item[na.rm] -- (необязательный) должны ли отбрасываться отсутствующие значения (NA)? (нет по умолчанию)
              \end{description}
        \end{mdframed}

	\item Постройте гистограмму частот распределения значений показателя.
		Сначала необходимо разбить диапазон изменений показателя на конечное число $k$
		непересекающихся интервалов $J_{i}, i=1,..,k$  и для каждого из них 
		подсчитать частоту попаданий значений показателя $l_{i}, i=\overline{1,n}$
		(т.е. число значений объединенной выборки, попавших в интервал).
		$k$ определяется формулой Стерджеса: $k=[1+\log_2 n]$.
		Для этого стоит использовать функцию \texttt{log2}

		\begin{mdframed}[style=BadassFrame]
			\texttt{log2(x)} \\
				-- вычисляет логарифм x по основанию 2.
			\begin{description}

				\item[x] -- вектор или число
			\end{description}
		\end{mdframed}

		Для получения правильного значения требуется написать простое ветвление для окргуления значения в большую сторону
		(подразумевается, что y.k - и есть коэффициент, вычисленный по формуле Стерджеса):\\
		\texttt{if (y.k > round(y.k)) y.k <- round(y.k) + 1 else y.k <- round(y.k)}
		
		Дальше построения гистограммы нам потребуется вычислить границы интервалов:
		\begin{itemize}
			\item[--] Вычислим шаг для интервала (y.delta - размах выборки):\\
				\texttt{y.step<-y.delta/y.k}
			\item[--] Подготовим вектор шагов:\\
				\texttt{y.steps<-(seq(1:(y.k+1))-1)*y.step}
			\item[--] Иницализиуем объект y.breaks:\\
				\texttt{y.breaks<-seq(0:8)}
			\item[--] Получим точные границы интервалов:\\
				\texttt{for (i in seq(1:(y.k+1))) y.breaks[i] <- y.steps[i] + y[1]}
		\end{itemize}

		Построим искомую гистограмму с помощью функции \texttt{hist}
		\begin{mdframed}[style=BadassFrame]
			\texttt{hist(x, breaks=br, density=NULL, angle=45, col=NULL, \\
				\phantom{    } border=NULL, main=paste("Histogram of", xname), \\
				\phantom{    } axes=TRUE, plot=TRUE ,...)} \\
				-- строит гистограмму на основе вектора x, с разделителями br.
			\begin{description}

				\item[x] -- вектор значений для гистограммы
				\item[breaks] -- (необязательный) Одно из:

					\begin{itemize}

						\item набор резделителей ячеек гистограммы
						\item функция для рассчета набора разделителей ячеек гистограммы
						\item количество ячеек гистограммы
						\item имя функции для рассчета набора разделителей ячеек гистограммы \\
							(\texttt{``Sturges'', ``Scott'', ``FD''}) 
						\item функция для рассчета количества ячеек
					\end{itemize}
				\item[density] -- (необязательный) плотность штриховки столбцов (без штриховки по умолчанию)
				\item[angle] -- (необязательный) угол наклона штриховки в градусах
				\item[col] -- (необязательный) цвет заливки столбцов (белый по умолчанию)
				\item[border] -- (необязательный) цвет границ столбцов (черный по умолчанию)
				\item[main] -- (необязательный) заголовок гистограммы, строка
				\item[axes] -- (необязательный) рисовать ли оси? (рисовать по умолчанию)
				\item[plot] -- (необязательный) строить ли график? (строить по умолчанию)
				\item[...] - дополнительные (необязательные) аргументы и графические параметры 
					(в данном случае не рассматриваются)
			\end{description}
		\end{mdframed}

		\texttt{hist(y, breaks=y.breaks)}.

		Для удобства стоит сохранить ее, например в \texttt{y.hist1}.
		В дальнейшем можно получить найденные частоты обратившись к вектору \texttt{y.hist1\$counts}.

	\item Вычислите относительные частоты попадания в каждый интервал разбиения.
		Относительная частота  равна значению соответствующей частоты, деленной на число элементов выборки: 
		$p_{i} = \frac{l_{i}}{n}, i=1,..,k$ .
		Сумма значений полученных относительных частот должна быть равна 1.\\
		Вычислим относительные частоты (N - объем вашей выборки):\\
		\texttt{y.rel\_fr<-y.hist1\$counts/N} \\
		Проверим их сумму:\\
		\texttt{sum(y.rel\_fr)}

	\item Подсчитайте кумулятивные (интегральные) частоты.
		Значение кумулятивной частоты для интервала представляет собой сумму частот 
		текущего и всех предыдущих интервалов (накопленные частоты):
		$F_{i}=\sum_{j=1}^i l_{i}, i=1,..,k$ .\\
		\texttt{y.cum\_fr<-seq(1:y.k)}\\
		\texttt{for (i in seq(1:y.k)) y.cum\_fr[i] <- sum(y.hist\$counts[1:i])}


	\item Вычислите относительные кумулятивные частоты,
		которые равны кумулятивным частотам, деленным на число элементов выборки.
		$F_{i}=\frac{\sum_{j=1}^i l_{i}}{n}, i=1,..,k$ .\\
		\texttt{y.cum\_rel\_fr<-seq(1:y.k)} \\
		\texttt{for (i in seq(1:y.k)) y.cum\_rel\_fr[i] <- sum(y.rel\_fr[1:i])}

\end{enumerate}
